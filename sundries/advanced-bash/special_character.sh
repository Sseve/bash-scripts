#!/bin/bash

# 除了开头(#!)其它以#开头的都是注释,不会被执行

# ; 命令行分隔符号[分号].允许在同一行放置多条命令.
echo hello; echo world

# ;; case条件语句终止符号[双分号]
# ;;&, ;& case条件语句终止符号(bash4+版本)

# . 可以作为文件名的一部分,如果它在文件名开头,说明此文件是隐藏文件
# . 作为目录表示当前目录,两个句点表示上层目录
# . 在正则表达式中,意味着匹配任意单个字符
# " 部分引用[双引号],在字符串中保留大部分特殊字符.
# ' 全引号[单引号],在字符串中保留所有的特殊字符.
# , 逗号运算符,将一系列的算术表达式串联在一起,算术表达式依次被执行,但只返回最后一个表达式的值,也可以用来连接字符串.
let "r = ((a = 9, 15 / 3))"
echo $a $r
# "' 在参数替换中进行小写字母转换(bash4新增)
# \ 转义符[反斜杠],转义某个字符的标志.
# / 文件路径分隔符[正斜杠],算术运算中的除法运算符
# ` 命令替换符, `command`结构可以使得命令的输出结果赋值给一个变量
# : 空命令[冒号],在shell中等价于"NOP"(即no op,空操作),与shell内建命令true有同样的效果,它本身也是bash内建命令,返回值时true(0),可以充当占位符
if [ 1 < 2 ]; then:
else
    echo "..."
fi
#
: ${username=`whoami`}
: ${1?"Usage: $0 arguent"}
: > data.txt   # 清空文件,不会改变文件权限的情况下清空文件.
: >> data.txt  # 将不会清空任何已经存在的文件,如果文件不存在,将创建这个文件
#
# ! 取反(或否定)操作符[感叹号]. !操作符反转已经执行的命令的返回状态.还可以反转测试操作符的意义.在一些特殊场景下,它会出现在间接变量引用中
# * 通配符号[星号],在文件匹配操作时扩展文件名,如果它独立出现则匹配该目录下的所有文件.在正则表达式中匹配任意多个前字符. 算术运算表乘法
# ** 双星号可以表示乘方运算或扩展文件匹配.
# ? 测试操作符[问号].在一些特定语句中,?表示条件测试
((a = b<5?1:2))  # 等价于
if [ $b -lt 5 ]; then
    a=1
else
    a=2
fi
# 在参数替换表达式中 ?用来测试一个变量是否已经被赋值, 通配符进行文件匹配时以单字符通配符扩展文件名,在正则表达式中匹配单个字符
# $ 取值符号,用来进行变量替换(取出变量的值).在正则表达式中表示行尾
# ${} 参数替换
# $'...' 引用字符串扩展.这个结构将转义八进制或十六进制的值转换成ASCII或Unicode字符
# $*, $@ 位置参数
# $? 返回状态变量,此变量保存一个命令,一个函数或该脚本本身的返回状态.
# $$ 进程ID变量,此变量保存当前脚本运行的进程ID
# () 命令组.通过括号执行一系列命令会产生一个子shell,括号中的变量在脚本其他部分时不可见的. 数组初始化
# {xx,yy} 花括号扩展结构.这个命令可以作用于花括号内有逗号分隔的文件描述列表,文件扩展(匹配)作用于大括号间的各个文件,除非被转义,否则空白符不应该出现在花括号中.
# {a..z} 扩展的花括号扩展结构,匹配a-z的小写字母
# {} 代码块[花括号],又被称作内联组,相当于一个匿名函数,但是其内部变量在脚本其他部分是可见的.代码块可以由i/o重定向输入或输出.文本占位符(与find命令一起用)
File=/etc/fstab
{
    read line1
    read line2
} < $File
#
# {}\; 路径名,通常与find命令一起使用
# [] 在[]之间填写测试表达式,它是shell内建命令test的一个组成部分.在数组变量中索引数组元素.在正则表达式中匹配指定字符集火字符范围内的任意字符
# [[]] 测试,在[[]]之间填写表达式,比[]更加灵活,它是shell的关键字
# $[...] 整数扩展,在$[]中可以计算整数的算术表达式.
# (()) 整数扩展符.在(())中可以计算整数的算术表达式
# > &> >& >> >>> < <> >| 重定向
# <, > ASCII码比较
# \<, \> 正则表达式中单词的边界
# | 管道符号,将上一个命令的输出作为下一个命令的输入,或者输入到bash中
# || 或逻辑运算符.在测试结构中,任意测试条件为真,整个表达式为真,返回0(成功标志位)
# & 后台运算符
# && 与逻辑运算符.在测试结构中,所有测试条件为真,整个表达式才为真,返回0
# - 选项前缀.重定向输入输出
(cd /source/directory && tar -cf - .) | (cd /dest/directory && tar xpvf -)  # 将整个文件数目录从一个目录移动到另一个目录
# - 还可以表示先前工作目录.减号
# = 赋值操作符号,在一些情况下可以作为字符串的比较操作
# + 加号,算术运算加.作为一个命令或过滤器的选项标记.特定的一些指令和内建命令使用+启用特定的选项,使用-禁用特定的选项.在参数代换中,+是作为变量扩展的备用值前缀
# % 取模运算符,一些情况下是模式匹配的操作符
# ~ 用户家目录
# ~+ 当前工作目录,等价于内部变量$PWD
# ~- 先前工作目录,等价于内部变量$OLDPWD
# =~ 正则表达式匹配
# ^ 行起始符,正则表达式中表示行首
# ^, ^^ 参数替换中的大写转换符(bash第4版新增)
# ctrl-A 移动光标至行首
# ctrl-B 非破坏性退格(即不删除字符)
# ctrl-C 中断指令,终止当前运行的任务
# ctrl-D 登出shell(类似exit)
# ctrl-E 移动光标至行末
# ctrl-F 光标向前移动一个字符
# ctrl-G 响铃BEL
# ctrl-H 抹除(破坏性退格)
# ctrl-I 水平制表符
# ctrl-J 换行
# ctrl-K 垂直制表
# ctrl-L 清屏
# ctrl-M 回车(CR)
# ctrl-N 在命令行历史记录中调用下一条历史命令
# ctrl-O 在命令行中另起一行
# ctrl-P 在命令行历史记录中调用上一条历史命令
# ctrl-Q 恢复(XON)
# ctrl-R 在命令行历史记录中进行搜索
# ctrl-S 挂起(XOFF)
# ctrl-T 交换光标所在字符与其前一个字符
# ctrl-U 删除光标所在字符之前的所有字符
# ctrl-V 输入时,使用ctrl-V允许插入控制字符.在文本编辑器中很有用
echo -e '\x0a'  # 等价于
echo <ctl-V><ctl-J>
# ctrl-W 当你在终端或 term窗口中输入字符时,Ctrl-W将会删除光标所在字符之前到其最近的空白符之间的所有字符.在一些情况下,Ctrl-W会删除到之前最近的非字母或数字的字符
# ctrl-X 在一些特定的文本处理程序中,剪切高亮文本并复制到剪贴板
# ctrl-Y 粘贴之前使用Ctrl-U或Ctrl-W删除的文字
# ctrl-Z 暂停当前运行的任务
# 空白符 作为命令或变量之间的分隔符.空白符包含空格,制表符,换行符或它们的任意组合.在一些地方,比如变量赋值时,空白符不应该出现,否则会造成语法错误